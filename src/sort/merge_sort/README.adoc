= 归并排序

归并排序首先将要排序的数组持续对切分，直到不能再切分。然后两两合并，将两个已排好序的数组合并成一个排好序的数组，不断重复这个过程，直至合并成一个。

假设我们要对数组 `[6, 5, 3, 1, 8, 2, 7, 9, 4]` 使用归并排序由小到大进行排序，下面来看看整个过程。

先将数组对半切分，得到 `[6, 5, 3, 1]` 和 `[8, 2, 7, 9, 4]`。继续对半拆分，直到不能拆分为止，最后拆成：`[6]`, `[5]`, `[3]`, `[1]`, `[8]`, `[2]`, `[7]`, `[9]`, `[4]`。

接下来对数组两两按顺序合并，由于是单个值合并，所以简单比较大小合并后得到：`[5, 6]`，`[1, 3]`，`[7, 8]`，`[2, 9]`，`[4]`，合并后的每一个数组都是有序的。

继续合并多个元素的数组，过程略微不同。先将 `[5, 6]` 与 `[1, 3]` 合并。将第一个数组的首个元素 `5` 与第二个数组的首个元素 `1` 进行比较。将较小的元素元素 `1` 放入新数组。再将第一个数组的首个元素 `5` 与第二个数组的首个元素 `3` 比较，将较小的 `3` 放入新数组末尾。第二个数组空了，依次将第一个数组的 `5` 和 `6` 放入新数组的末尾，得到新数组 `[1, 3, 5, 6]`。

接着合并 `[7, 8]` 和 `[2, 9]`。对两个数组的第一个元素进行比较，将最小的取出放入新数组：`[2]`，剩下 `[7, 8]` 和 `[9]`，继续比较两个数组的首个元素，得到新数组：`[2, 7]`，剩下：`[8]`，`[9]`；继续完成合并后得到：`[2, 7, 8, 9]`。

现在对 `[1, 3, 5, 6]` 和 `[2, 7, 8, 9]` 合并得到：`[1, 2, 3, 5, 6, 7, 8, 9]`。然后将它与 `[4]` 合并，得到最终结果：`[1, 2, 3, 4, 5, 6, 7, 8, 9]`。

从整个排序过程来看，用递归来实现应该会更直观：

https://github.com/oobot/learning-algorithms/blob/932f5486e4932b7620e24d799b938917dc4e0332/src/sort/merge_sort/mod.rs#L2-L40

`merge_sort` 函数通过递归调用，将数组不断折半拆分，待拆到在只有两个元素的"最小数组"时开始调用 `merge` 函数，`merge` 将 `array` 按 `mid` 分成两半，然后有序合并到一个新数组里。虽然递归的实现符合计算机思维，但排序的中间值一直存放在栈中，在要排序的数组很大时，调用栈会堆叠很深，可能会导致栈溢出。另外，循环的性能通常优于递归调用。下面用循环实现归并排序：

https://github.com/oobot/learning-algorithms/blob/2afaf62b084e0b08b9eeb5dac4a1b3173a17ee64/src/sort/merge_sort/iterative_merge_sort.rs#L3-L48

== 性能
归并排序是稳定的排序，初始数组是否已经排序不会影响归并排序算法的速度，最好和最坏的情况时间复杂度都是 _O_(__n__log__n__)。优于插入排序、选择排序和冒泡排序。不过归并排序并不是原地排序，它需要一个同等大小的"临时"数组存放中间结果，有时候这可能是个问题。
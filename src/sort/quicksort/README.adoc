= 快速排序

快速排序算法由英国计算机科学家 Tony Hoare 于1959提出，并于1961年发表。它由冒泡排序算法改进过来，在平均情况下时间复杂度是__O__(__n__log__n__)，有很高的效率，是如今最广泛使用的排序算法之一。

快速排序算法实现方式有多种，我们先来看一个比较符合直觉的，它可以分为以下几步：

1. 在数组中选一个基准数（方便起见，通常是第一个）。
2. 不断比较数组左右两侧的元素，将小于基准数的移到基准数左边，大于基准数的移到基准数右边。
3. 对于基准数左右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素为止，此时数组已全部有序。

以数组 `[5, 7, 1, 8, 4]` 为例， 先看第一轮，以 `5` 为基准数排序：

1. 与倒数第一个元素 `4` 比较，得到：`[4, 7, 1, 8, _]`。
2. 与顺数基准数之后的第一个元素 `7` 比较，得到：`[4, _, 1, 8, 7]`。
3. 与 `8` 比较，数组`8`大于`5`，数组保持不变。
4. 跟 `1` 比较，将`1`移到"空位"，得到：`[4, 1, _, 8, 7]`。
5. 此时数组左右两侧的索引相遇了，把基准数放入"空位"，得到 `[4, 1, 5, 8, 7]`。

第一轮排序结束了，可以看到 `5` 把数组分成了两部分，左侧部分所有元素都小于`5`，右侧所有元素都大于`5`。接下来，依照第一轮的方法，把左右部分分别排序，就能得到有序的数组了。

代码示例：
https://github.com/oobot/learning-algorithms/blob/90cfd67014767416453aca8718906ad2c2f2729e/src/sort/quicksort/mod.rs#L3-L27

这个代码实现满足上述过程，也能得出正确的结果，但略显繁冗。它在一次循环里比较两个值，而这两段代码逻辑是相同的。我们可以简化代码实现，让它每次循环只比较一个值。当然了，这是另外一种实现。

1. 从数组中挑出一个基准数。
2. 依次比较数组元素，比基准数小的排在前面，比基准数大的排在基准数后面，相同的可以排在任意一边（这里像冒泡排序）。比较结束后，基准数就处于数组中间位置，这也被称为__分区 (partition)__操作。
3. 递归地将小于基准数的子数组和大于基准数的子数组排序。

以数组 `[5, 7, 1, 8, 4, 2]` 为例，选取第一个数 `5` 为基准数，
1. 比较第二个数，`7` 大于 `5`，啥都不做。
2. 继续比较下一个，`1` 小于 `5`，将 `7` 基准数之后的第一个元素交换位置，即与 `1` 的位置交换，此时数组为：`[5, 1, 7, 8, 4, 2]`。
3. 继续比较下一个，`8` 大于 `5`，什么都不用做。
4. 继续比较下一个，`4` 小于 `5`，`4` 和基准数之后的第二个元素 `7` 交换位置，此时数组为：`[5, 1, 4, 8, 7, 2]`。
5. 继续比较最后一个，`2` 小于 `5`，`2` 和基准数之后的第三个元素 `8` 交换位置，此时数组为：`[5, 1, 4, 2, 7, 8]`。
6. 最后，基准数与最后一次交换位置的元素交换位置，即将 `5` 和基准数之后的第三个元素（这一轮总共对调了三次元素，最后一次交换位置的是基准数之后的第三个元素） `2` 交换位置，得到：`[2, 1, 4, 5, 7, 8]`。

这一轮排序完成后，`5` 左边的元素全都小于5，右边的元素全都大于5。之后只要继续对左右两边的元素排序，即可完成整个数组的排序。

代码示例：
https://github.com/oobot/learning-algorithms/blob/44fd7d2be239b89468442ce1a7f3493421d1c634/src/sort/quicksort/mod.rs#L30-L45

代码实现比第一种简洁多了。快速排序并非稳定的排序，其性能取决于划分是否平衡，而平衡与否又依赖于划分的元素。如果划分是平衡的，那么快速排序算法与归并排序的性能是一样的。如果划分不平衡，那么快速排序的性能就接近于插入排序了。也就是说，通常情况下，快速排序的性能是__O__(__n__log__n__)，最坏的情况是__O__(_n_^2^)。另外，快速排序还需要少量的额外空间__O__(log__n__)来存储中间数据，但可以忽略不计。

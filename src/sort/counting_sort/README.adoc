= 计数排序

计数排序并非基于比较元素的排序，在排序过程中不存在元素交换。它通过计算元素的值，映射到计数数组的相应位置，计数数组的索引，就是元素的顺序。

我们以数组 `[6, 9, 6, 2, 8]` 为例。先创建一个计数数组并且初始值是0，新数组的长度为待排序数组的最大值减去最小值再加一，这个数组是 `9-2+1`，长度是8。然后通过 `i - 2` 将第 `i` 个元素映射到计数数组的对应的位置，将上面的值 +1。开始遍历数组：

1. 第一个元素 `6` 通过 `6 - 2` 计算出对应计数数组的第五个为止，我们将索引4的值 +1：`[0, 0, 0, 0, 1, 0, 0, 0]`。
2. 第二个元素 `9` 对应第八个元素，我们对索引7的值 +1：`[0, 0, 0, 0, 1, 0, 0, 1]`。
3. 第三个元素 `6` 对应第五个元素，将索引4的值 +1：`[0, 0, 0, 0, 2, 0, 0, 1]`。
4. 最后两个元素，计算后得到：`[1, 0, 0, 0, 2, 0, 1, 1]`。

然后逆向这个过程，迭代计数数组，通过将索引加上数组最小值 `i + min`，反向计算出相应的值添加到新数组。

1. 第一个元素索引0处有一个值，`0+2`得到 `2`，我们将一个 `2` 添加到新数组：`[2]`。
2. 再来到索引4，它有两个值，计算后得到的 `6`，将它追加到新数组：`[2, 6, 6]`。
3. 将索引6和7通过计算后的值也添加到新数组：`[2, 6, 6, 8, 9]`。

代码实现：


这种方式有些像哈希表，通过某种算法，将元素映射存储在数组的相应位置。 计数排序方式是有局限性的，它只适用于整数排序。因为其他类型的值没法确定新计数数组的长度，也就无法使用简单的"映射"算法将值映射到数组的相应位置。除了局限性，它还有个缺点，如果数组的最大值和最小值相差巨大，远大于数组的长度，那么按照 `max - min + 1` 开辟新数组会造成巨大浪费。

用空间换时间

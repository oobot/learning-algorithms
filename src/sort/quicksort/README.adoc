= 快速排序

快速排序算法由英国计算机科学家 Tony Hoare 于1959提出，并于1961年发表。它由冒泡排序算法改进过来，在平均情况下时间复杂度是__O__(__n__log__n__)，有很高的效率，是如今最广泛使用的排序算法之一。

快速排序算法实现方式有多种，我们先来看一个比较符合直觉的，它可以分为以下几步：
1. 在数组中选一个基准数（方便起见，通常是第一个）。
2. 不断比较数组左右两侧的元素，将小于基准数的移到基准数左边，大于基准数的移到基准数右边。
3. 对于基准数左右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素为止，此时数组已全部有序。

以数组 `[5, 7, 1, 8, 4]` 为例， 先看第一轮，以 `5` 为基准数排序：

1. 与倒数第一个元素 `4` 比较，得到：`[4, 7, 1, 8, _]`。
2. 与顺数基准数之后的第一个元素 `7` 比较，得到：`[4, _, 1, 8, 7]`。
3. 与 `8` 比较，数组`8`大于`5`，数组保持不变。
4. 跟 `1` 比较，将`1`移到"空位"，得到：`[4, 1, _, 8, 7]`。
5. 此时数组左右两侧的索引相遇了，把基准数放入"空位"，得到 `[4, 1, 5, 8, 7]`。

第一轮排序结束了，可以看到 `5` 把数组分成了两部分，左侧部分所有元素都小于`5`，右侧所有元素都大于`5`。接下来，依照第一轮的方法，把左右部分分别排序，就能得到有序的数组了。

代码示例：
https://github.com/oobot/learning-algorithms/blob/90cfd67014767416453aca8718906ad2c2f2729e/src/sort/quicksort/mod.rs#L3-L27

这个代码实现满足上述过程，也能得出正确的结果，但略显繁冗。它在一次循环里比较两个值，而这两段代码逻辑是相同的。我们可以简化代码实现，让它每次循环只比较一个值。当然了，这是另外一种实现。

1. 从数组中挑出一个基准数。
2. 依次比较数组元素，比基准数小的排在前面，比基准数大的排在基准数后面，相同的可以排在任意一边（挺像冒泡排序）。比较结束后，基准数就处于数组中间位置，这也被称为__分区 (partition)__操作。
3. 递归地将小于基准数的子数组和大于基准数的子数组排序。

还是以数组 `[5, 7, 1, 8, 4]` 为例，选取第一个数 `5` 为基准数，

代码示例：
https://github.com/oobot/learning-algorithms/blob/90cfd67014767416453aca8718906ad2c2f2729e/src/sort/quicksort/mod.rs#L29-L47


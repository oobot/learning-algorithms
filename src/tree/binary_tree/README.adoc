= 二叉树

如果树中的每个节点最多只有两个子节点，这样的树称为"二叉树"，它是最简单，也是最常用的树。二叉树每个节点左边的子节点称为"左子结点"，右边子节点称为"右子节点"。当然，二叉树的节点不是必须有两个子节点，它可以只有一个子节点，右子节点或左子节点，也可以没有子节点，这种情况它是叶节点。

如果一个节点的左子结点值小于这个节点的值，右子节点值大于或等于这个节点值，这样的二叉树称为"二叉查找树"。下图展示了一棵二叉查找树。

image::../../../assets/images/tree/binary_search_tree.svg[alt="", title="二叉查找树"]

非平衡树:: 如果一棵树的大部分节点在根节点的左边或右边，那么这颗树就是非平衡树。下图展示了一棵非平衡树。

image::../../../assets/images/tree/unbalanced_binary_search_tree.svg[alt="", title="非平衡二叉查找树"]

树之所以变得不平衡，是由于数据项插入顺序导致的。如果插入值的大小是随机的，树整体会变得比较平衡。反之，如果以升序插入值，所有值都会是右子节点，如果以降序插入值，那么所有值都会是左子节点。实际上，多少都会有些短的升序或降序的数列出现，这会使树的局部不平衡。如果一棵树过于失衡，它的效率会严重退化。往后的AVL树和红黑树会涉及这个话题。

== 用代码表示树

用 `Node` 表示一个节点，节点有 `T` 类型的值，可能有左子节点和右子节点。`Tree` 表示一棵树，查找、插入和删除方法定义在 `Tree` 上。


== 查找

假设要查找值为57的节点，为了方便讨论，以下图举例说明。首先57和根节点63比较，57较小，所以要找的结果可能在当前节点的左侧。继续往下查找左子结点，左子节点的值是27，小于57，所以结果可能在当前节点右侧。继续往下查找右子节点，58比57大，所以结果可能在左子结点。继续找左子结点，这个节点的值是57，与我们要找的值相等，所以这个就是我们要找的节点。

image::../../../assets/images/tree/search_node.svg[alt="", title="查找节点"]

代码示例：

=== 效率
从上面的查找过程可以看出，二叉查找树查找节点的时间复杂度是__O__(log__n__)，查找节点所需的次数取决于这个节点所在的层数。节点所在层数越浅，所需步骤越少；层数越深，所需步骤就越多。

== 插入

二叉查找树成立的条件是：对于每一个子树，左子结点 < 父节点 < 右子节点。要插入节点，首先得找到插入的地方。从根节点开始查找，插入后满足这个条件的地方，就是新节点将要插入的地方，如下图所示。*新插入的节点始终是叶子结点*。

image::../../../assets/images/tree/insert_node.svg[alt="", title="插入节点"]

代码示例：


== 遍历

=== 查找最大值和最小值

== 删除

== 效率

== 用数组表示树
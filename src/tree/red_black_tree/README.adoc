= 红黑树

如果一棵二叉树的左子结点数量和右子节点数量大致相等，我们称它为平衡二叉树。随机向二叉查找树添加数据，会得到一棵比较平衡的树，平衡的二叉查找树执行效率很好。但是，如果插入的是有序的数据，效率就会变得很低了。因为如果数据是升序的数据，所有节点都会作为右子节点插入到树中，如果是降序，会以左节点形式插入树中。不管升序还是降序，都会让二叉查找树实质上退化成一个链表。查找效率也从__O__(log__n__)退化成__O__(_n_)。即使有序的只有一部分，也会让树变得不平衡，查找效率也不如__O__(log__n__)。

由此可见，让二叉查找树维持平衡，才保持高效率。红黑树 (Red-Black Tree) 便是平衡二叉查找树中的一种。红黑树的应用比较广泛，例如，Java 集合中的 TreeSet 和 TreeMap，C++ STL 中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树来实现的。红黑树主要用作存储有序数据，它的时间复杂度是__O__(log__n__)，效率非常高。

红黑树本质上是一棵二叉查找树。

除了二叉查找树的规则之外，红黑树还多了这些规则：

1. 每个节点要么是黑色要么是红色。
2. 根节点始终是黑色。
3. 每个叶子结点（null）都是黑色的。
4. 两个红色节点不能直接相连。
5. 从一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。

节点颜色只是一个比喻，并不是非得红色和黑色，用任意两种颜色来表示都可以。这些规则是用来保证红黑树自平衡的。规则4和规则5确保红黑树是接近平衡的二叉树，任意节点到叶子节点最长路径不超出最短路径的两倍。另外，与二叉查找树不同的是，红黑树中不存在相同值的节点。

下图是一棵典型的红黑树。

image::images/red_black_tree.svg[alt="", title="一棵红黑树"]


== 红黑树自平衡

当插入节点和删除节点时，可能会破坏平衡，需要对树重新调整以恢复平衡。调整方式有两种：旋转和变色。

=== 变色

变色就是黑边红或者红变黑。当插入红色节点与规则4和规则5相悖情况时，需要对父节点甚至一直往上的节点变色。

=== 旋转

旋转有左旋转和右旋转，即逆时针旋转和顺时针旋转。如下图。

image::images/binary_tree_rotations.svg[title="树的旋转"]

左旋转就是提升右子节点替换父节点，右旋转是提升左子结点为父节点，然后再重新连接子节点。动画清晰地展示了这个过程。

image::images/tree_rotation_animation.gif[title="树的旋转动画"]




























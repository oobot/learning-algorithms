= 计数排序

计数排序并非基于比较元素的排序，在排序过程中不存在元素交换。它通过计算元素的值，映射到计数数组的相应位置，而计数数组的索引顺序，就是元素的顺序。

我们以数组 `[6, 9, 6, 2, 8]` 为例。先创建一个计数数组并且初始值是0，计数数组的长度为待排序数组的最大值减去最小值再加一，这个数组是 `9-2+1`，长度是8。然后通过 `i - 2` 将第 `i` 个元素映射到计数数组的对应的位置，将上面的值 +1。

开始遍历数组：

1. 第一个元素 `6` 通过 `6 - 2` 计算出对应计数数组的第五个为止，我们将索引4的值 +1：`[0, 0, 0, 0, 1, 0, 0, 0]`。
2. 第二个元素 `9` 对应第八个元素，我们对索引7的值 +1：`[0, 0, 0, 0, 1, 0, 0, 1]`。
3. 第三个元素 `6` 对应第五个元素，将索引4的值 +1：`[0, 0, 0, 0, 2, 0, 0, 1]`。
4. 最后两个元素，计算后得到：`[1, 0, 0, 0, 2, 0, 1, 1]`。

然后逆向这个过程，迭代计数数组，通过将索引加上数组最小值 `i + min`，反向计算出相应的值添加到新数组。

1. 第一个元素索引0处有一个值，`0+2`得到 `2`，我们将一个 `2` 添加到新数组：`[2]`。
2. 再来到索引4，它有两个值，计算后得到的 `6`，将它追加到新数组：`[2, 6, 6]`。
3. 将索引6和7通过计算后的值也添加到新数组：`[2, 6, 6, 8, 9]`。

代码实现：
https://github.com/oobot/learning-algorithms/blob/8a3e1e58a9be53dcfbcde47f09f9d2b76e69f36f/src/sort/counting_sort/mod.rs#L3-L26

整个过程需要遍历两次长度为 n 的数组，一次确定最大值和最小值，另一次是给计数器计数（k 个计数器）。最后遍历计数器，反向计算出数组值。所以计数排序的时间复杂度是__O__(_n_+_k_)。额外的空间复杂度__O__(_k_)。 计数排序有些像哈希表，通过某种算法，将元素映射存储在数组的相应位置。

我们知道，归并排序是一种高效且稳定的排序，在任何情况下其时间复杂度都是__O__(__n__log__n__)，而计数排序的时间复杂度突破了下界，达到了线性的复杂度，是到目前为止接触的最快的排序算法。

计数排序是有局限性的，它只适用于整数排序。因为其他类型的值无法确定新计数数组的长度，也就无法使用简单的"映射"算法将值映射到数组的相应位置。除了局限性，它还有个缺点，如果数组的最大值和最小值相差巨大，远大于数组的长度，那么按照 `max - min + 1` 开辟新数组会造成巨大浪费。

通常情况下，我们认为空间相对低廉，时间更宝贵。计数排序是一种牺牲内存空间来换取低时间复杂度的排序算法。在设计或使用一个算法的过程中，我们需要同时考虑时间复杂度和空间复杂度，并在这两者中找到一个平衡点。
